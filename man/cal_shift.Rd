% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shift.R
\name{cal_shift}
\alias{cal_shift}
\title{Shift dates relative to a business calendar}
\usage{
cal_shift(x, period = "1 day", convention = conventions$following,
  calendar = default_calendar())
}
\arguments{
\item{x}{\code{[Date]}

The dates to shift.}

\item{period}{\code{[character(1), lubridate::Period]}

The period to shift \code{x} with. This is allowed to be a character such as
\code{"1 day"}, which is parsed by \code{\link[lubridate:period]{lubridate::period()}}, or a lubridate
Period object generated from one of the helpers, such as
\code{\link[lubridate:days]{lubridate::days()}}.

The period is restricted to any combination of years, months, weeks, or
days. Higher resolution periods such as hours, minutes, and seconds
are not allowed.

Negative period values are allowed, to shift backwards.}

\item{convention}{\code{[character(1)]}

A business day convention to follow if the date you land on after shifting
is a holiday. These conventions only apply for monthly / yearly periods.
For daily periods, the date is always shifted to the next available
business day. The following conventions are available in the \link{conventions}
object:
\itemize{
\item \code{"following"}

Choose the first business day after the given holiday.
\item \code{"modified_following"}

Choose the first business day after the given
holiday unless it belongs to a different month, in which case choose the
first business day before the holiday.
\item \code{"preceding"}

Choose the first business day before the given holiday.
\item \code{"modified_preceding"}

Choose the first business day before the given holiday unless it belongs
to a different month, in which case choose the first business day after
the holiday.
\item \code{"unadjusted"}

No adjustment is made.
\item \code{"half_month_modified_following"}

Choose the first business day after the given holiday unless that day
crosses the mid-month (15th) or the end of month, in which case choose
the first business day before the holiday.
\item \code{"nearest"}

Choose the nearest business day to the given holiday. If both the
preceding and following business days are equally far away, default to
following business day.
}}

\item{calendar}{\code{[calendar]}

A calendar.}
}
\description{
\code{cal_shift()} shifts a vector of dates by a \code{period}, while respecting
business calendar rules.
}
\examples{
library(lubridate)

x <- as.Date("2018-12-18") + 0:3
x

# The 22nd and 23rd are weekends so
# "2018-12-21" is shifted to the next available
# business day, "2018-12-24"
cal_shift(x, "1 day")

# The 25th is Christmas
# The following occurs because we skip over the weekend:
# "2018-12-20" -> "2018-12-24"
# Here, first we land at "2018-12-24" after skipping over the weekend,
# then we go one more business day forward to "2018-12-26", skipping
# over Christmas
# "2018-12-21" -> "2018-12-26"
cal_shift(x, "2 day")

# We could define a calendar where Christmas for that year is not a holiday
cal <- calendar()
cal <- holidays_remove(cal, "2018-12-25")
cal_shift(x, "2 day", calendar = cal)

# ---------------------------------------------------------------------------
# Conventions

# In this case, moving forward 1 month would land on New Years. The
# default convention is to move to the "following" business day
cal_shift("2019-12-01", months(1))

# We can adjust this with the convention argument. Here we ask to move
# to the first business day before the holiday that we landed on
cal_shift("2019-12-01", months(1), "preceding")

# If you are okay with landing on New Years, use unadjusted.
cal_shift("2019-12-01", months(1), "unadjusted")

# 2010 was special because New Year was celebrated on the
# last day of December.
cal_shift("2009-12-31", years(1))

# In this case, "modified_following" can be useful. It generally
# shifts forward unless the holiday you land on is the end of the month,
# in which case it rolls back to the previous business day.
cal_shift("2009-12-31", years(1), "modified_following")

# Which means it gives the same result as preceding here
cal_shift("2009-12-31", years(1), "preceding")

}
